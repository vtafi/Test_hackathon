import React, { useEffect, useRef, useState } from "react";
import "./MapView.css";

const MapView = ({ places, apiKey, floodZones = [] }) => {
  const mapRef = useRef(null);
  const map = useRef(null);
  const platform = useRef(null);
  const markersGroup = useRef(null);
  const floodOverlayGroup = useRef(null);
  const routeGroup = useRef(null);
  const [mapReady, setMapReady] = useState(false);
  
  // üöó Routing states
  const [routeStart, setRouteStart] = useState(null);
  const [routeEnd, setRouteEnd] = useState(null);
  const [currentRoute, setCurrentRoute] = useState(null);
  const [routingMode, setRoutingMode] = useState(false);
  const [routeInfo, setRouteInfo] = useState(null);
  const [userLocation, setUserLocation] = useState(null);
  const [locationPermission, setLocationPermission] = useState('prompt'); // 'granted', 'denied', 'prompt'
  const [routeWarning, setRouteWarning] = useState(null); // C·∫£nh b√°o route ƒëi qua v√πng ng·∫≠p
  const [allRoutes, setAllRoutes] = useState([]); // T·∫•t c·∫£ routes alternatives
  const [selectedRouteIndex, setSelectedRouteIndex] = useState(0); // Route ƒëang ƒë∆∞·ª£c ch·ªçn

  // Kh·ªüi t·∫°o b·∫£n ƒë·ªì
  useEffect(() => {
    // Ch·ªù HERE Maps library load
    const initMap = () => {
      console.log("Initializing map...");
      console.log("window.H:", !!window.H);
      console.log("mapRef.current:", !!mapRef.current);
      console.log("apiKey:", !!apiKey);

      if (!window.H) {
        console.error("HERE Maps library ch∆∞a ƒë∆∞·ª£c load");
        return;
      }

      if (!mapRef.current) {
        console.error("Map container ch∆∞a s·∫µn s√†ng");
        return;
      }

      if (!apiKey) {
        console.error("Thi·∫øu API key");
        return;
      }

      // Kh·ªüi t·∫°o platform
      if (!platform.current) {
        platform.current = new window.H.service.Platform({
          apikey: apiKey,
        });
      }

      // Kh·ªüi t·∫°o map
      if (!map.current) {
        try {
          const defaultLayers = platform.current.createDefaultLayers();

          map.current = new window.H.Map(
            mapRef.current,
            defaultLayers.vector.normal.map,
            {
              zoom: 12,
              center: { lat: 16.0544, lng: 108.2022 },
              pixelRatio: window.devicePixelRatio || 1,
            }
          );

          // Th√™m behavior (zoom, pan, drag)
          new window.H.mapevents.Behavior(
            new window.H.mapevents.MapEvents(map.current)
          );

          // Th√™m UI controls (zoom buttons, scale bar)
          window.H.ui.UI.createDefault(map.current, defaultLayers);

          // X·ª≠ l√Ω resize
          const handleResize = () => {
            if (map.current) {
              map.current.getViewPort().resize();
            }
          };

          window.addEventListener("resize", handleResize);

          console.log("Map initialized successfully");
          setMapReady(true); // ‚úÖ ƒê√°nh d·∫•u map ƒë√£ s·∫µn s√†ng

          return () => {
            window.removeEventListener("resize", handleResize);
          };
        } catch (error) {
          console.error("L·ªói khi kh·ªüi t·∫°o map:", error);
        }
      }
    };

    // Delay ƒë·ªÉ ƒë·∫£m b·∫£o DOM ƒë√£ s·∫µn s√†ng
    const timer = setTimeout(() => {
      initMap();
    }, 100);

    return () => {
      clearTimeout(timer);
    };
  }, [apiKey]);

  // C·∫≠p nh·∫≠t markers khi places thay ƒë·ªïi
  useEffect(() => {
    if (!map.current || !window.H || !places || places.length === 0) return;

    // X√≥a markers c≈©
    if (markersGroup.current) {
      map.current.removeObject(markersGroup.current);
    }

    // T·∫°o group m·ªõi cho markers
    markersGroup.current = new window.H.map.Group();

    places.forEach((place, index) => {
      if (place.position) {
        // T·∫°o SVG marker v·ªõi gradient ƒë·∫πp
        const svgMarkup = `
          <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="markerGrad${index}" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
              </linearGradient>
              <filter id="shadow${index}" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
                <feOffset dx="0" dy="2" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.3"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            <circle cx="20" cy="20" r="18" fill="url(#markerGrad${index})" 
                    stroke="white" stroke-width="3" filter="url(#shadow${index})"/>
            <text x="20" y="26" font-size="18" font-weight="bold" 
                  text-anchor="middle" fill="white" font-family="Arial">${
                    index + 1
                  }</text>
          </svg>
        `;

        const icon = new window.H.map.Icon(svgMarkup, {
          anchor: { x: 20, y: 20 },
        });

        // T·∫°o marker
        const marker = new window.H.map.Marker(
          { lat: place.position.lat, lng: place.position.lng },
          { icon: icon }
        );

        // L∆∞u th√¥ng tin v√†o marker
        marker.setData({
          index: index + 1,
          title: place.title,
          address: place.address?.label || "Kh√¥ng c√≥ ƒë·ªãa ch·ªâ",
          categories: place.categories || [],
          distance: place.distance || 0,
          position: place.position,
          type: "place",
        });

        // Th√™m event click ƒë·ªÉ hi·ªÉn th·ªã info bubble
        marker.addEventListener("tap", (evt) => {
          const data = evt.target.getData();
          showInfoBubble(data, data.position);
        });

        markersGroup.current.addObject(marker);
      }
    });

    // Th√™m group v√†o map
    map.current.addObject(markersGroup.current);

    // Auto zoom ƒë·ªÉ hi·ªÉn th·ªã t·∫•t c·∫£ markers
    if (places.length > 0 && markersGroup.current.getBoundingBox()) {
      const bounds = markersGroup.current.getBoundingBox();
      map.current.getViewModel().setLookAtData({
        bounds: bounds,
        zoom: 12,
      });
    }
  }, [places]);

  // H√†m hi·ªÉn th·ªã info bubble cho places
  const showInfoBubble = (data, position) => {
    const bubbleContent = `
      <div class="info-bubble-content">
        <div class="bubble-header">
          <span class="bubble-number">${data.index}</span>
          <h3 class="bubble-title">${data.title}</h3>
        </div>
        <div class="bubble-body">
          <p class="bubble-address">
            <span class="bubble-icon">üìç</span>
            ${data.address}
          </p>
          ${
            data.distance
              ? `
            <p class="bubble-distance">
              <span class="bubble-icon">üìè</span>
              Kho·∫£ng c√°ch: <strong>${(data.distance / 1000).toFixed(
                2
              )} km</strong>
            </p>
          `
              : ""
          }
          ${
            data.categories && data.categories.length > 0
              ? `
            <div class="bubble-categories">
              ${data.categories
                .map(
                  (cat) => `
                <span class="bubble-tag">${cat.name}</span>
              `
                )
                .join("")}
            </div>
          `
              : ""
          }
          <p class="bubble-coords">
            <span class="bubble-icon">üåê</span>
            ${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}
          </p>
        </div>
      </div>
    `;

    // T·∫°o v√† hi·ªÉn th·ªã info bubble
    const ui = window.H.ui.UI.createDefault(
      map.current,
      platform.current.createDefaultLayers()
    );

    const bubble = new window.H.ui.InfoBubble(
      { lat: position.lat, lng: position.lng },
      { content: bubbleContent }
    );

    ui.addBubble(bubble);
  };

  // üé® H√†m l·∫•y m√†u theo risk level
  const getRiskColors = (riskLevel) => {
    const colors = {
      high: {
        fill: 'rgba(244, 67, 54, 0.45)',    // ƒê·ªè trong su·ªët
        stroke: 'rgba(244, 67, 54, 0.9)',   // Vi·ªÅn ƒë·ªè ƒë·∫≠m
      },
      medium: {
        fill: 'rgba(255, 193, 7, 0.45)',    // V√†ng trong su·ªët
        stroke: 'rgba(255, 193, 7, 0.9)',   // Vi·ªÅn v√†ng ƒë·∫≠m
      },
      low: {
        fill: 'rgba(76, 175, 80, 0.45)',    // Xanh l√° trong su·ªët
        stroke: 'rgba(76, 175, 80, 0.9)',   // Vi·ªÅn xanh ƒë·∫≠m
      },
      default: {
        fill: 'rgba(54, 162, 235, 0.45)',   // Xanh d∆∞∆°ng trong su·ªët
        stroke: 'rgba(54, 162, 235, 0.9)',  // Vi·ªÅn xanh ƒë·∫≠m
      }
    };
    return colors[riskLevel] || colors.default;
  };

  // üó∫Ô∏è H√†m hi·ªÉn th·ªã info bubble cho flood zones
  const showFloodInfoBubble = (data, position) => {
    const riskLevelText = {
      high: 'Cao',
      medium: 'Trung b√¨nh',
      low: 'Th·∫•p'
    };

    const bubbleContent = `
      <div class="info-bubble-content">
        <div class="bubble-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
          <span class="bubble-icon">‚ö†Ô∏è</span>
          <h3 class="bubble-title">${data.name || 'Khu v·ª±c ng·∫≠p l·ª•t'}</h3>
        </div>
        <div class="bubble-body">
          ${data.district ? `
            <p class="bubble-district">
              <span class="bubble-icon">üìç</span>
              ${data.district}
            </p>
          ` : ''}
          <p class="bubble-risk">
            <span class="bubble-icon">üö®</span>
            M·ª©c ƒë·ªô r·ªßi ro: <strong style="color: ${getRiskColors(data.riskLevel).stroke}">${riskLevelText[data.riskLevel] || 'Kh√¥ng x√°c ƒë·ªãnh'}</strong>
          </p>
          ${data.description ? `
            <p class="bubble-description">
              <span class="bubble-icon">üìù</span>
              ${data.description}
            </p>
          ` : ''}
          ${data.rainThreshold ? `
            <div class="bubble-threshold">
              <p><strong>Ng∆∞·ª°ng c·∫£nh b√°o m∆∞a:</strong></p>
              <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                <li>üü° V√†ng: ${data.rainThreshold.yellow}mm</li>
                <li>üü† Cam: ${data.rainThreshold.orange}mm</li>
                <li>üî¥ ƒê·ªè: ${data.rainThreshold.red}mm</li>
              </ul>
            </div>
          ` : ''}
          <p class="bubble-coords">
            <span class="bubble-icon">üåê</span>
            ${position.lat.toFixed(5)}, ${position.lng.toFixed(5)}
          </p>
        </div>
      </div>
    `;

    const ui = window.H.ui.UI.createDefault(
      map.current,
      platform.current.createDefaultLayers()
    );

    const bubble = new window.H.ui.InfoBubble(
      { lat: position.lat, lng: position.lng },
      { content: bubbleContent }
    );

    ui.addBubble(bubble);
  };

  // üó∫Ô∏è V·∫Ω flood zones overlay
  useEffect(() => {
    console.log("üîç Flood overlay effect triggered");
    console.log("  - mapReady:", mapReady);
    console.log("  - map.current:", !!map.current);
    console.log("  - window.H:", !!window.H);
    console.log("  - floodZones:", floodZones?.length || 0);
    
    if (!mapReady || !map.current || !window.H || !floodZones || floodZones.length === 0) {
      console.log("‚ö†Ô∏è Skipping flood overlay - waiting for:", {
        mapReady: mapReady,
        map: !map.current,
        H: !window.H,
        zones: !floodZones || floodZones.length === 0
      });
      return;
    }

    console.log("‚úÖ Drawing flood zones:", floodZones.length);

    // X√≥a overlay c≈© n·∫øu c√≥
    if (floodOverlayGroup.current) {
      try {
        map.current.removeObject(floodOverlayGroup.current);
      } catch (e) {
        console.log("Note: Could not remove old overlay group");
      }
    }

    // T·∫°o group m·ªõi cho flood overlay
    floodOverlayGroup.current = new window.H.map.Group();
    console.log("üì¶ Created new flood overlay group");

    let circleCount = 0;
    floodZones.forEach((zone, index) => {
      if (zone.coords || (zone.lat && zone.lng)) {
        const lat = zone.coords?.lat || zone.lat;
        const lng = zone.coords?.lng || zone.lng;
        const radius = zone.radius || 500; // B√°n k√≠nh m·∫∑c ƒë·ªãnh 500m

        console.log(`  üéØ Creating overlay ${index + 1}/${floodZones.length}:`, zone.name, `at (${lat}, ${lng})`);

        // L·∫•y m√†u s·∫Øc theo risk level
        const colors = getRiskColors(zone.riskLevel);
        console.log(`    - Color: ${colors.fill} (${zone.riskLevel})`);

        // T·∫°o circle overlay
        const circle = new window.H.map.Circle(
          { lat: lat, lng: lng },
          radius,
          {
            style: {
              fillColor: colors.fill,
              strokeColor: colors.stroke,
              lineWidth: 2.5,
            },
          }
        );

        // L∆∞u th√¥ng tin v√†o circle
        circle.setData({
          id: zone.id,
          name: zone.name,
          district: zone.district,
          riskLevel: zone.riskLevel,
          description: zone.description,
          rainThreshold: zone.rainThreshold,
          coords: { lat, lng },
        });

        // Th√™m event click
        circle.addEventListener("tap", (evt) => {
          const data = evt.target.getData();
          showFloodInfoBubble(data, data.coords);
        });

        floodOverlayGroup.current.addObject(circle);
        circleCount++;
        console.log(`    ‚úÖ Circle added to group`);
      }
    });

    console.log(`üìä Created ${circleCount} circles out of ${floodZones.length} zones`);

    // Th√™m group v√†o map
    map.current.addObject(floodOverlayGroup.current);

    console.log("‚úÖ Flood zones overlay added successfully!");
    console.log("üìç Total overlays on map:", floodZones.length);
  }, [mapReady, floodZones]);

  // üìç GEOLOCATION FUNCTIONS
  
  // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
  const requestUserLocation = () => {
    if (!navigator.geolocation) {
      alert('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Geolocation!');
      setLocationPermission('denied');
      return;
    }

    console.log('üìç ƒêang y√™u c·∫ßu v·ªã tr√≠ ng∆∞·ªùi d√πng...');

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const userPos = {
          lat: position.coords.latitude,
          lng: position.coords.longitude
        };
        
        setUserLocation(userPos);
        setRouteStart(userPos);
        setLocationPermission('granted');
        
        console.log('‚úÖ V·ªã tr√≠ ng∆∞·ªùi d√πng:', userPos);
        
        // T·∫°o marker v·ªã tr√≠ hi·ªán t·∫°i
        if (map.current && window.H) {
          const userMarker = createUserLocationMarker(userPos.lat, userPos.lng);
          
          if (!routeGroup.current) {
            routeGroup.current = new window.H.map.Group();
            map.current.addObject(routeGroup.current);
          }
          
          routeGroup.current.addObject(userMarker);
          
          // Center map t·ªõi v·ªã tr√≠ ng∆∞·ªùi d√πng
          map.current.setCenter(userPos);
          map.current.setZoom(14);
        }
        
        alert('‚úÖ ƒê√£ l·∫•y v·ªã tr√≠ c·ªßa b·∫°n! B√¢y gi·ªù h√£y click v√†o b·∫£n ƒë·ªì ƒë·ªÉ ch·ªçn ƒëi·ªÉm ƒë·∫øn.');
      },
      (error) => {
        console.error('‚ùå L·ªói geolocation:', error);
        setLocationPermission('denied');
        
        let message = 'Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ c·ªßa b·∫°n. ';
        switch (error.code) {
          case error.PERMISSION_DENIED:
            message += 'B·∫°n ƒë√£ t·ª´ ch·ªëi chia s·∫ª v·ªã tr√≠. Vui l√≤ng cho ph√©p trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.';
            break;
          case error.POSITION_UNAVAILABLE:
            message += 'Th√¥ng tin v·ªã tr√≠ kh√¥ng kh·∫£ d·ª•ng.';
            break;
          case error.TIMEOUT:
            message += 'Timeout khi l·∫•y v·ªã tr√≠.';
            break;
          default:
            message += 'L·ªói kh√¥ng x√°c ƒë·ªãnh.';
        }
        alert(message);
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    );
  };

  // T·∫°o marker cho v·ªã tr√≠ hi·ªán t·∫°i
  const createUserLocationMarker = (lat, lng) => {
    const svgMarkup = `
      <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
        <circle cx="20" cy="20" r="8" fill="#2196F3" stroke="white" stroke-width="3"/>
        <circle cx="20" cy="20" r="14" fill="none" stroke="#2196F3" stroke-width="2" opacity="0.5"/>
      </svg>
    `;

    const icon = new window.H.map.Icon(svgMarkup, {
      anchor: { x: 20, y: 20 }
    });

    const marker = new window.H.map.Marker({ lat, lng }, { icon });
    marker.setData({ type: 'user-location' });
    return marker;
  };

  // Ki·ªÉm tra 1 ƒëi·ªÉm c√≥ n·∫±m trong flood zone kh√¥ng
  const isPointInFloodZone = (lat, lng) => {
    if (!floodZones || floodZones.length === 0) return null;

    for (const zone of floodZones) {
      const zoneLat = zone.coords?.lat || zone.lat;
      const zoneLng = zone.coords?.lng || zone.lng;
      const radius = zone.radius || 500;

      // T√≠nh kho·∫£ng c√°ch (simple distance)
      const distance = calculateSimpleDistance(lat, lng, zoneLat, zoneLng);
      
      if (distance <= radius) {
        return zone; // N·∫±m trong v√πng ng·∫≠p
      }
    }
    
    return null;
  };

  // T√≠nh kho·∫£ng c√°ch ƒë∆°n gi·∫£n (meters)
  const calculateSimpleDistance = (lat1, lng1, lat2, lng2) => {
    const R = 6371000; // Earth radius in meters
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  // Ki·ªÉm tra route c√≥ ƒëi qua v√πng ng·∫≠p kh√¥ng
  const checkRouteFloodIntersection = (routePolyline) => {
    if (!floodZones || floodZones.length === 0) return [];
    
    const affectedZones = [];
    const lineString = window.H.geo.LineString.fromFlexiblePolyline(routePolyline);
    const routePoints = lineString.getLatLngAltArray();
    
    // Check m·ªói 10 ƒëi·ªÉm tr√™n route (ƒë·ªÉ t·ªëi ∆∞u performance)
    for (let i = 0; i < routePoints.length; i += 30) {
      const lat = routePoints[i];
      const lng = routePoints[i + 1];
      
      const zone = isPointInFloodZone(lat, lng);
      if (zone && !affectedZones.find(z => z.id === zone.id)) {
        affectedZones.push(zone);
      }
    }
    
    return affectedZones;
  };

  // üöó ROUTING FUNCTIONS
  
  // T·∫°o marker cho ƒëi·ªÉm start/end
  const createRouteMarker = (lat, lng, type) => {
    if (!window.H) return null;

    const svgMarkup = type === 'start' 
      ? `<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
           <circle cx="20" cy="20" r="15" fill="#4CAF50" stroke="white" stroke-width="3"/>
           <text x="20" y="27" font-size="20" text-anchor="middle" fill="white" font-weight="bold">A</text>
         </svg>`
      : `<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
           <circle cx="20" cy="20" r="15" fill="#F44336" stroke="white" stroke-width="3"/>
           <text x="20" y="27" font-size="20" text-anchor="middle" fill="white" font-weight="bold">B</text>
         </svg>`;

    const icon = new window.H.map.Icon(svgMarkup, {
      anchor: { x: 20, y: 20 }
    });

    const marker = new window.H.map.Marker({ lat, lng }, { icon });
    marker.setData({ type });
    return marker;
  };

  // T√≠nh to√°n route (c√≥ ki·ªÉm tra v√πng ng·∫≠p)
  const calculateRoute = (start, end, avoidFloods = true) => {
    if (!platform.current || !window.H) {
      console.error("Platform not ready");
      return;
    }

    console.log("üöó Calculating route from", start, "to", end);
    console.log("üåä Avoid floods:", avoidFloods);

    const router = platform.current.getRoutingService(null, 8);
    
    // Build avoid areas t·ª´ flood zones
    let avoidAreas = [];
    if (avoidFloods && floodZones && floodZones.length > 0) {
      avoidAreas = floodZones.map(zone => {
        const lat = zone.coords?.lat || zone.lat;
        const lng = zone.coords?.lng || zone.lng;
        const radius = zone.radius || 500;
        // Format: lat,lng;r=radiusInMeters
        return `${lat},${lng};r=${radius}`;
      });
      console.log(`üö´ Avoiding ${avoidAreas.length} flood zones`);
    }
    
    const routingParameters = {
      routingMode: 'fast',
      transportMode: 'car',
      origin: `${start.lat},${start.lng}`,
      destination: `${end.lat},${end.lng}`,
      return: 'polyline,summary,actions,instructions',
      alternatives: 3  // T√≠nh 3 routes ƒë·ªÉ c√≥ nhi·ªÅu l·ª±a ch·ªçn
    };

    // Th√™m avoid areas n·∫øu c√≥
    if (avoidAreas.length > 0) {
      routingParameters.avoid = {
        areas: avoidAreas.slice(0, 10) // HERE API gi·ªõi h·∫°n t·ªëi ƒëa avoid areas
      };
    }

    router.calculateRoute(
      routingParameters,
      (result) => {
        console.log("‚úÖ Route calculated:", result);
        
        if (result.routes && result.routes.length > 0) {
          console.log(`üìä Nh·∫≠n ƒë∆∞·ª£c ${result.routes.length} routes, ƒëang ph√¢n t√≠ch...`);
          
          // üéØ CH·ªåN ROUTE T·ªêT NH·∫§T
          let bestRoute = null;
          let bestRouteIndex = 0;
          let minFloodZones = Infinity;
          
          // Ph√¢n t√≠ch t·ª´ng route
          const routeAnalysis = result.routes.map((route, index) => {
            const section = route.sections[0];
            const affectedZones = checkRouteFloodIntersection(section.polyline);
            const distance = section.summary.length / 1000; // km
            
            console.log(`  üìç Route ${index + 1}:`);
            console.log(`     - Kho·∫£ng c√°ch: ${distance.toFixed(2)} km`);
            console.log(`     - V√πng ng·∫≠p: ${affectedZones.length} zones`);
            
            return {
              route,
              section,
              affectedZones,
              distance,
              floodCount: affectedZones.length
            };
          });
          
          // Ch·ªçn route √çT ng·∫≠p nh·∫•t, n·∫øu b·∫±ng nhau th√¨ ch·ªçn ng·∫Øn nh·∫•t
          routeAnalysis.forEach((analysis, index) => {
            if (analysis.floodCount < minFloodZones) {
              minFloodZones = analysis.floodCount;
              bestRoute = analysis;
              bestRouteIndex = index;
            } else if (analysis.floodCount === minFloodZones) {
              // N·∫øu c√πng s·ªë v√πng ng·∫≠p, ch·ªçn route ng·∫Øn h∆°n
              if (analysis.distance < bestRoute.distance) {
                bestRoute = analysis;
                bestRouteIndex = index;
              }
            }
          });
          
          console.log(`‚úÖ T·ª± ƒë·ªông ch·ªçn route ${bestRouteIndex + 1} (${bestRoute.floodCount} v√πng ng·∫≠p, ${bestRoute.distance.toFixed(2)} km)`);
          
          // L∆∞u T·∫§T C·∫¢ routes ƒë·ªÉ user c√≥ th·ªÉ ch·ªçn
          setAllRoutes(routeAnalysis);
          setSelectedRouteIndex(bestRouteIndex);
          
          // X√≥a route c≈©
          if (routeGroup.current) {
            map.current.removeObject(routeGroup.current);
          }
          
          // T·∫°o group m·ªõi
          routeGroup.current = new window.H.map.Group();
          
          // üé® V·∫º T·∫§T C·∫¢ ROUTES
          const routeColors = [
            { main: '#4CAF50', selected: '#2E7D32' }, // Xanh l√°
            { main: '#2196F3', selected: '#1565C0' }, // Xanh d∆∞∆°ng
            { main: '#9C27B0', selected: '#6A1B9A' }, // T√≠m
          ];
          
          routeAnalysis.forEach((analysis, index) => {
            const isSelected = index === bestRouteIndex;
            const hasFlood = analysis.floodCount > 0;
            
            // Ch·ªçn m√†u d·ª±a v√†o flood
            let color;
            if (hasFlood) {
              color = isSelected ? '#E65100' : '#FF9800'; // Cam/ƒë·ªè cam n·∫øu c√≥ ng·∫≠p
            } else {
              const colorScheme = routeColors[index % routeColors.length];
              color = isSelected ? colorScheme.selected : colorScheme.main;
            }
            
            const lineString = window.H.geo.LineString.fromFlexiblePolyline(analysis.section.polyline);
            const routeLine = new window.H.map.Polyline(lineString, {
              style: {
                strokeColor: color,
                lineWidth: isSelected ? 8 : 5,
                lineCap: 'round',
                lineJoin: 'round',
                lineDash: isSelected ? [] : [10, 5] // Selected = solid, others = dashed
              },
              zIndex: isSelected ? 100 : 50 + index,
              data: {
                routeIndex: index,
                routeInfo: analysis
              }
            });
            
            // Th√™m click event ƒë·ªÉ ch·ªçn route
            routeLine.addEventListener('tap', () => {
              selectRoute(index);
            });
            
            routeGroup.current.addObject(routeLine);
          });
          
          // Th√™m markers
          const startMarker = userLocation 
            ? createUserLocationMarker(start.lat, start.lng)
            : createRouteMarker(start.lat, start.lng, 'start');
          const endMarker = createRouteMarker(end.lat, end.lng, 'end');
          
          routeGroup.current.addObject(startMarker);
          routeGroup.current.addObject(endMarker);
          
          // Th√™m v√†o map
          map.current.addObject(routeGroup.current);
          
          // Zoom to first route
          const firstLineString = window.H.geo.LineString.fromFlexiblePolyline(routeAnalysis[0].section.polyline);
          const firstLine = new window.H.map.Polyline(firstLineString);
          map.current.getViewModel().setLookAtData({
            bounds: firstLine.getBoundingBox()
          });
          
          // Hi·ªÉn th·ªã info c·ªßa route ƒë∆∞·ª£c ch·ªçn
          updateRouteInfo(bestRouteIndex, routeAnalysis);
        }
      },
      (error) => {
        console.error('‚ùå Routing error:', error);
        
        // N·∫øu l·ªói v√¨ avoid qu√° nhi·ªÅu v√πng, th·ª≠ l·∫°i kh√¥ng avoid
        if (avoidFloods && error.message && error.message.includes('avoid')) {
          console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ tr√°nh t·∫•t c·∫£ v√πng ng·∫≠p, t√≠nh route th√¥ng th∆∞·ªùng...');
          calculateRoute(start, end, false);
        } else {
          alert('Kh√¥ng th·ªÉ t√≠nh to√°n ƒë∆∞·ªùng ƒëi. Vui l√≤ng th·ª≠ l·∫°i!');
        }
      }
    );
  };

  // üéØ Ch·ªçn route t·ª´ danh s√°ch alternatives
  const selectRoute = (index) => {
    if (!allRoutes || index >= allRoutes.length) return;
    
    console.log(`üìç User ch·ªçn route ${index + 1}`);
    setSelectedRouteIndex(index);
    updateRouteInfo(index, allRoutes);
    
    // V·∫Ω l·∫°i routes v·ªõi highlight route m·ªõi
    redrawRoutesWithSelection(index);
  };
  
  // üìä Update th√¥ng tin route
  const updateRouteInfo = (index, routeAnalysis) => {
    const analysis = routeAnalysis[index];
    const section = analysis.section;
    const affectedZones = analysis.affectedZones;
    
    const distance = analysis.distance.toFixed(2);
    const duration = Math.round(section.summary.duration / 60);
    
    setCurrentRoute(analysis.route);
    setRouteInfo({
      distance: `${distance} km`,
      duration: `${duration} ph√∫t`,
      instructions: section.actions || [],
      safeRoute: affectedZones.length === 0,
      routeNumber: index + 1,
      totalRoutes: routeAnalysis.length
    });
    
    // Set warning n·∫øu c√≥ v√πng ng·∫≠p
    if (affectedZones.length > 0) {
      console.warn(`‚ö†Ô∏è Route ${index + 1} ƒëi qua ${affectedZones.length} v√πng ng·∫≠p:`, affectedZones.map(z => z.name));
      
      setRouteWarning({
        type: 'flood_intersection',
        zones: affectedZones,
        message: `‚ö†Ô∏è C·∫£nh b√°o: ƒê∆∞·ªùng ƒëi qua ${affectedZones.length} khu v·ª±c ng·∫≠p l·ª•t!`,
        alternativesChecked: routeAnalysis.length
      });
    } else {
      console.log(`‚úÖ Route ${index + 1} an to√†n`);
      setRouteWarning(null);
    }
    
    console.log(`üìç Route ${index + 1}: ${distance} km, ${duration} ph√∫t`);
  };
  
  // üé® V·∫Ω l·∫°i routes v·ªõi route ƒë∆∞·ª£c ch·ªçn
  const redrawRoutesWithSelection = (selectedIndex) => {
    if (!routeGroup.current || !allRoutes || !map.current) return;
    
    // X√≥a t·∫•t c·∫£ route lines (gi·ªØ l·∫°i markers)
    const objects = routeGroup.current.getObjects();
    objects.forEach(obj => {
      if (obj instanceof window.H.map.Polyline) {
        routeGroup.current.removeObject(obj);
      }
    });
    
    // V·∫Ω l·∫°i v·ªõi highlight m·ªõi
    const routeColors = [
      { main: '#4CAF50', selected: '#2E7D32' },
      { main: '#2196F3', selected: '#1565C0' },
      { main: '#9C27B0', selected: '#6A1B9A' },
    ];
    
    allRoutes.forEach((analysis, index) => {
      const isSelected = index === selectedIndex;
      const hasFlood = analysis.floodCount > 0;
      
      let color;
      if (hasFlood) {
        color = isSelected ? '#E65100' : '#FF9800';
      } else {
        const colorScheme = routeColors[index % routeColors.length];
        color = isSelected ? colorScheme.selected : colorScheme.main;
      }
      
      const lineString = window.H.geo.LineString.fromFlexiblePolyline(analysis.section.polyline);
      const routeLine = new window.H.map.Polyline(lineString, {
        style: {
          strokeColor: color,
          lineWidth: isSelected ? 8 : 5,
          lineCap: 'round',
          lineJoin: 'round',
          lineDash: isSelected ? [] : [10, 5]
        },
        zIndex: isSelected ? 100 : 50 + index,
        data: {
          routeIndex: index,
          routeInfo: analysis
        }
      });
      
      routeLine.addEventListener('tap', () => {
        selectRoute(index);
      });
      
      routeGroup.current.addObject(routeLine);
    });
  };
  
  // X√≥a route
  const clearRoute = () => {
    if (routeGroup.current && map.current) {
      map.current.removeObject(routeGroup.current);
      routeGroup.current = null;
    }
    // Gi·ªØ l·∫°i user location n·∫øu c√≥
    if (userLocation) {
      setRouteStart(userLocation);
    } else {
      setRouteStart(null);
    }
    setRouteEnd(null);
    setCurrentRoute(null);
    setRouteInfo(null);
    setRouteWarning(null);
    setAllRoutes([]);
    setSelectedRouteIndex(0);
    console.log("üóëÔ∏è Route cleared");
  };

  // Toggle routing mode
  const toggleRoutingMode = () => {
    const newMode = !routingMode;
    setRoutingMode(newMode);
    
    if (newMode) {
      // Khi b·∫≠t routing mode, y√™u c·∫ßu v·ªã tr√≠ ng∆∞·ªùi d√πng
      requestUserLocation();
    } else {
      // Khi t·∫Øt, clear route v√† user location
      clearRoute();
      setUserLocation(null);
      setLocationPermission('prompt');
    }
    
    console.log("üöó Routing mode:", newMode ? "ON" : "OFF");
  };

  // Handle map click for routing
  useEffect(() => {
    if (!mapReady || !map.current || !routingMode) return;

    const handleMapClick = (evt) => {
      if (!routingMode) return;

      const coord = map.current.screenToGeo(
        evt.currentPointer.viewportX,
        evt.currentPointer.viewportY
      );

      const point = {
        lat: coord.lat,
        lng: coord.lng
      };

      // N·∫æU ƒê√É C√ì USER LOCATION (t·ª´ geolocation)
      if (userLocation) {
        // Ch·ªâ c·∫ßn ch·ªçn ƒëi·ªÉm ƒë·∫øn
        if (!routeEnd || currentRoute) {
          setRouteEnd(point);
          console.log("üìç Destination set:", point);
          // T√≠nh route ngay t·ª´ user location ‚Üí ƒëi·ªÉm ƒë·∫øn
          calculateRoute(userLocation, point);
        }
      } else {
        // Ch·∫ø ƒë·ªô c≈©: ch·ªçn 2 ƒëi·ªÉm th·ªß c√¥ng
        if (!routeStart) {
          setRouteStart(point);
          console.log("üìç Start point set:", point);
        } else if (!routeEnd) {
          setRouteEnd(point);
          console.log("üìç End point set:", point);
          calculateRoute(routeStart, point);
        } else {
          // Reset n·∫øu ƒë√£ c√≥ route
          clearRoute();
          setRouteStart(point);
          console.log("üìç New start point:", point);
        }
      }
    };

    map.current.addEventListener('tap', handleMapClick);

    return () => {
      map.current.removeEventListener('tap', handleMapClick);
    };
  }, [mapReady, routingMode, routeStart, routeEnd, userLocation, currentRoute]);

  if (!apiKey) {
    return (
      <div className="map-error">
        <div className="error-content">
          <span className="error-icon">‚ö†Ô∏è</span>
          <h3>Thi·∫øu API Key</h3>
          <p>Vui l√≤ng th√™m HERE API Key v√†o file .env</p>
        </div>
      </div>
    );
  }

  return (
    <div className="map-view">
      <div ref={mapRef} className="map-container" />
      
      {/* üöó Routing Controls */}
      <div className="routing-controls">
        <button 
          className={`routing-toggle-btn ${routingMode ? 'active' : ''}`}
          onClick={toggleRoutingMode}
          title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô d·∫´n ƒë∆∞·ªùng tr√°nh ng·∫≠p"
        >
          {routingMode ? 'üó∫Ô∏è T·∫Øt d·∫´n ƒë∆∞·ªùng' : 'üöó D·∫´n ƒë∆∞·ªùng tr√°nh ng·∫≠p'}
        </button>
        
        {routingMode && (
          <div className="routing-instructions">
            {/* Location Permission Status */}
            {locationPermission === 'prompt' && !userLocation && (
              <div className="routing-hint location-prompt">
                <span className="hint-icon">üìç</span>
                <span>ƒêang y√™u c·∫ßu quy·ªÅn truy c·∫≠p v·ªã tr√≠...</span>
              </div>
            )}
            
            {locationPermission === 'denied' && (
              <div className="routing-hint location-denied">
                <span className="hint-icon">‚ö†Ô∏è</span>
                <span>Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p v·ªã tr√≠. Vui l√≤ng ch·ªçn ƒëi·ªÉm xu·∫•t ph√°t th·ªß c√¥ng.</span>
              </div>
            )}
            
            {/* Instructions based on user location */}
            {userLocation && !routeEnd && (
              <div className="routing-hint location-granted">
                <span className="hint-icon">‚úÖ</span>
                <span>ƒê√£ l·∫•y v·ªã tr√≠ c·ªßa b·∫°n! Click v√†o b·∫£n ƒë·ªì ƒë·ªÉ ch·ªçn ƒëi·ªÉm ƒë·∫øn.</span>
              </div>
            )}
            
            {!userLocation && !routeStart && locationPermission !== 'prompt' && (
              <div className="routing-hint">
                <span className="hint-icon">üìç</span>
                <span>Click v√†o b·∫£n ƒë·ªì ƒë·ªÉ ch·ªçn ƒëi·ªÉm xu·∫•t ph√°t (A)</span>
              </div>
            )}
            
            {!userLocation && routeStart && !routeEnd && (
              <div className="routing-hint">
                <span className="hint-icon">üìç</span>
                <span>Click ti·∫øp ƒë·ªÉ ch·ªçn ƒëi·ªÉm ƒë·∫øn (B)</span>
              </div>
            )}
            
            {/* Flood Warning */}
            {routeWarning && (
              <div className="route-warning">
                <div className="warning-header">
                  <span className="warning-icon">‚ö†Ô∏è</span>
                  <h4>C·∫£nh b√°o ng·∫≠p l·ª•t!</h4>
                </div>
                <p className="warning-message">{routeWarning.message}</p>
                <div className="warning-zones">
                  <strong>Khu v·ª±c ng·∫≠p tr√™n ƒë∆∞·ªùng:</strong>
                  <ul>
                    {routeWarning.zones.map((zone, idx) => (
                      <li key={idx}>
                        üî¥ {zone.name} ({zone.district})
                      </li>
                    ))}
                  </ul>
                </div>
                <p className="warning-note">
                  üí° H·ªá th·ªëng ƒë√£ c·ªë g·∫Øng t√¨m ƒë∆∞·ªùng tr√°nh ng·∫≠p. N·∫øu kh√¥ng tr√°nh ƒë∆∞·ª£c, vui l√≤ng c√¢n nh·∫Øc tuy·∫øn ƒë∆∞·ªùng kh√°c.
                </p>
              </div>
            )}
            
            {/* Route Alternatives Selection */}
            {allRoutes.length > 1 && (
              <div className="route-alternatives">
                <div className="alternatives-header">
                  <h4>üó∫Ô∏è Ch·ªçn tuy·∫øn ƒë∆∞·ªùng ({allRoutes.length} l·ª±a ch·ªçn)</h4>
                  <span className="alternatives-hint">Click v√†o route tr√™n b·∫£n ƒë·ªì ho·∫∑c ch·ªçn b√™n d∆∞·ªõi:</span>
                </div>
                <div className="alternatives-list">
                  {allRoutes.map((route, index) => {
                    const isSelected = index === selectedRouteIndex;
                    const hasFlood = route.floodCount > 0;
                    
                    return (
                      <div 
                        key={index}
                        className={`alternative-item ${isSelected ? 'selected' : ''} ${hasFlood ? 'has-flood' : 'safe'}`}
                        onClick={() => selectRoute(index)}
                      >
                        <div className="alternative-number">
                          {isSelected ? '‚úì' : index + 1}
                        </div>
                        <div className="alternative-info">
                          <div className="alternative-main">
                            <span className="alternative-distance">{route.distance.toFixed(2)} km</span>
                            <span className="alternative-duration">
                              {Math.round(route.section.summary.duration / 60)} ph√∫t
                            </span>
                          </div>
                          <div className="alternative-status">
                            {hasFlood ? (
                              <span className="flood-badge">
                                ‚ö†Ô∏è {route.floodCount} v√πng ng·∫≠p
                              </span>
                            ) : (
                              <span className="safe-badge">‚úÖ An to√†n</span>
                            )}
                          </div>
                        </div>
                        <div className="alternative-legend">
                          <div 
                            className="route-color-indicator"
                            style={{
                              backgroundColor: hasFlood 
                                ? (isSelected ? '#E65100' : '#FF9800')
                                : (index === 0 ? '#4CAF50' : index === 1 ? '#2196F3' : '#9C27B0')
                            }}
                          />
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            )}
            
            {/* Route Info */}
            {routeInfo && (
              <div className="route-info-panel">
                <div className={`route-info-header ${routeInfo.safeRoute ? 'safe' : 'warning'}`}>
                  <h3>
                    {routeInfo.safeRoute ? '‚úÖ ƒê∆∞·ªùng ƒëi an to√†n' : '‚ö†Ô∏è C·∫£nh b√°o ng·∫≠p'}
                    {routeInfo.totalRoutes > 1 && (
                      <span className="route-number-badge">Route {routeInfo.routeNumber}/{routeInfo.totalRoutes}</span>
                    )}
                  </h3>
                  <button onClick={clearRoute} className="clear-route-btn">
                    üóëÔ∏è X√≥a
                  </button>
                </div>
                <div className="route-stats">
                  <div className="stat-item">
                    <span className="stat-icon">üìè</span>
                    <span className="stat-label">Kho·∫£ng c√°ch:</span>
                    <span className="stat-value">{routeInfo.distance}</span>
                  </div>
                  <div className="stat-item">
                    <span className="stat-icon">‚è±Ô∏è</span>
                    <span className="stat-label">Th·ªùi gian:</span>
                    <span className="stat-value">{routeInfo.duration}</span>
                  </div>
                  <div className="stat-item">
                    <span className="stat-icon">{routeInfo.safeRoute ? '‚úÖ' : '‚ö†Ô∏è'}</span>
                    <span className="stat-label">Tr·∫°ng th√°i:</span>
                    <span className={`stat-value ${routeInfo.safeRoute ? 'safe' : 'danger'}`}>
                      {routeInfo.safeRoute ? 'An to√†n' : 'C√≥ ng·∫≠p'}
                    </span>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default MapView;
